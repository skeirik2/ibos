set include BOOL off .

--- Booleans
fmod IBOOL is
  pr BOOL-OPS .
endfm

fmod INAT is
  pr IBOOL .

  sort iNat .
  op 0 : -> iNat [ctor] .
  op s_ : iNat -> iNat [ctor] .

  vars N N' : iNat .

**** Relational operators
  op _<=_ : iNat iNat -> Bool .
  op _<_  : iNat iNat -> Bool .
  eq 0 <= N' 
   = true .
  eq s(N) <= 0
   = false .
  eq s(N) <= s(N')
   = N <= N' .
  eq N <= N
   = true .
  eq N < 0
   = false .
  eq s(N) < s(N')
   = N < N' .
  eq N < N' 
   = false .

**** Equality enrichment (added by Camilo)
  op _~_ : iNat iNat -> Bool .
  eq N ~ N
   = true .
  eq 0 ~ 0
   = true .
  eq 0 ~ s(N')
   = false .
  eq s(N) ~ 0
   = false .
  eq s(N) ~ s(N')
   = N ~ N' .
  eq N ~ s(N)
   = false .

**** Mapping for constants that are convenient for reducing
**** the time in the verification of the admissibility of
**** the specification
  ops 256 1023 1024 1056 : -> iNat .
  eq 256 = s(s(0)) .
  eq 1023 = s(s(s(256))) .
  eq 1024 = s(1023) .
  eq 1056 = s(s(s(1024))) .
endfm

**** Copied and slightly modified from prelude.maude
mod CONFIGURATION is
  sorts Attribute AttributeSet .
  subsort Attribute < AttributeSet .
  op none : -> AttributeSet  [ctor] .
  op _,_ : AttributeSet AttributeSet -> AttributeSet [ctor assoc comm id: none] .

  sorts Oid Cid Object Msg Portal Configuration .
  subsort Object Msg Portal < Configuration .
  op <_:_|_> : Oid Cid AttributeSet -> Object [ctor] .
  op none : -> Configuration [ctor] .
  op __ : Configuration Configuration -> Configuration [ctor assoc comm id: none] .
  op <> : -> Portal [ctor] .
endm

mod SYS is
  pr CONFIGURATION .
  sort Sys .
  op {_} : Configuration -> Sys [ctor] .
endm

mod PROC-ID is
  including CONFIGURATION .
  protecting INAT .

  sort ProcId .
  subsort iNat < ProcId  < Oid .
  
**** Alternative way for identifying procs (by Camilo)
  op id : iNat -> ProcId [ctor] .
**** Equality enrichment (added by Camilo)
  op _~_ : ProcId ProcId -> Bool [ditto] .
  eq P:ProcId ~ P:ProcId = true .
  eq id(N:iNat) ~ id(N':iNat) = N:iNat ~ N':iNat .
  eq id(N:iNat) ~ N':iNat = false .
  eq N:iNat ~ id(N':iNat) = false .

---(
  new conventions

  none		       is now id(0)
  kernel-id            is now id(1)
  webappmgr-id         is now id(2)
  webapp-id            is now id(3)
  network-id           is now id(4)
  cache-id             is now id(5)
  cookie-id	       is now id(6)
  vesafb-server-id     is now id(7)
  mouse-server-id      is now id(8)
  network-server-id    is now id(9)
  dns-server-id	       is now id(10)
  ui-id		       is now id(11)
  mouse-intr-id	       is now id(12)
  network-intr-id      is now id(13)
  storage-id	       is now id(14)
  display-id	       is now id(15)
)

**** component IDs as constants.
**** everything is a process, only the kernel is special
  op kernel : -> Cid [ctor] . 
  op proc : -> Cid [ctor] .
**** The NIC and dma-memory are special as well, there is only one
**** NIC, called 0 and the dma-memory belongs to a process, noted by
**** same id.
  op nic : -> Cid [ctor] .
  op mem : -> Cid [ctor] .
endm 

mod MSG-TYPE is
  protecting INAT .

**** different types of messages
  sort MsgType .
**** values are associated to types
  sort MsgVal .
  subsort iNat < MsgVal .

**** Q: where can i find the list of such messages in current code?
**** A: ibos_source/dOs/op.h - note this goes into the message payload
  op MSG-NEW-URL                    : -> MsgType [ctor] .
  op MSG-FETCH-URL                  : -> MsgType [ctor] .
  op MSG-RETURN-URL                 : -> MsgType [ctor] .
  op MSG-SET-URL                    : -> MsgType [ctor] .
  op MSG-UPDATE-URL                 : -> MsgType [ctor] .
  op MSG-UPDATA-CONTAINER           : -> MsgType [ctor] .
  op MSG-FETCH-URL-ABORT            : -> MsgType [ctor] .
  op MSG-SET-LOCATION-BAR           : -> MsgType [ctor] .
  op MSG-SET-STATUS-BAR             : -> MsgType [ctor] .
  op MSG-SET-CAPTION                : -> MsgType [ctor] .
  op MSG-FROM-VNC-CLIENT            : -> MsgType [ctor] .
  op MSG-FROM-VNC-SERVER            : -> MsgType [ctor] .
  op MSG-VNC-INIT                   : -> MsgType [ctor] .
  op MSG-NAV-SET-WEBAPP             : -> MsgType [ctor] .
  op MSG-NEW-WEBAPP                 : -> MsgType [ctor] .
  op MSG-SWITCH-TAB                 : -> MsgType [ctor] .
  op MSG-NAV-STOP                   : -> MsgType [ctor] .
  op MSG-GET-OBJECT-AUDIT-RECORDS   : -> MsgType [ctor] .
  op MSG-QUERY-AUDIT-LOG-REPLY      : -> MsgType [ctor] .
  op MSG-EXTENSION-ACTION           : -> MsgType [ctor] .
  op MSG-STORE-OBJECT               : -> MsgType [ctor] .
  op MSG-RETRV-OBJECT               : -> MsgType [ctor] .
  op MSG-RETURN-URL-METADATA        : -> MsgType [ctor] .
  op MSG-OBJECT-ADD-ACL-USER        : -> MsgType [ctor] .
  op MSG-OBJECT-REM-ACL-USER        : -> MsgType [ctor] .
  op MSG-OBJECT-DOWNLOAD-READY      : -> MsgType [ctor] .
  op MSG-JS-EVALUATE                : -> MsgType [ctor] .
  op MSG-JS-REPLY                   : -> MsgType [ctor] .
  op MSG-JS-SET-HANDLER-CODE        : -> MsgType [ctor] .
  op MSG-JS-INVOKE-HANDLER          : -> MsgType [ctor] .
  op MSG-SNAP-SHOT                  : -> MsgType [ctor] .
  op MSG-REPLAY-WEBAPP              : -> MsgType [ctor] .
  op MSG-SET-POLICY                 : -> MsgType [ctor] .
  op MSG-LOG-BEHAVIOR-DATA          : -> MsgType [ctor] .
  op MSG-LOG-USER-INPUT             : -> MsgType [ctor] .
  op MSG-SET-REPLAY-MODE            : -> MsgType [ctor] .
  op MSG-SAVE-DOM                   : -> MsgType [ctor] .
  op MSG-ACK-REPLAY-MSG             : -> MsgType [ctor] .
  op MSG-EMBED-FRAME                : -> MsgType [ctor] .

  op MSG-COOKIE-SET                 : -> MsgType [ctor] .
  op MSG-COOKIE-REMOVE              : -> MsgType [ctor] .
  op MSG-COOKIE-LISTDOMAINS         : -> MsgType [ctor] .
  op MSG-COOKIE-GET                 : -> MsgType [ctor] .
  op MSG-COOKIE-GET-RETURN          : -> MsgType [ctor] .
  op MSG-COOKIE-NEWJAR              : -> MsgType [ctor] .
  op MSG-COOKIE-NUMJARS             : -> MsgType [ctor] .
  op MSG-COOKIE-USEJAR              : -> MsgType [ctor] .

  op MSG-PLUGIN-NPN                 : -> MsgType [ctor] .
  op MSG-PLUGIN-NPP                 : -> MsgType [ctor] .
  op MSG-PLUGIN-EXECUTE             : -> MsgType [ctor] .
  op MSG-PLUGIN-SET-URL             : -> MsgType [ctor] .

  op MSG-DOM-COOKIE-SET             : -> MsgType [ctor] .
  op MSG-DOM-COOKIE-GET             : -> MsgType [ctor] .
  op MSG-DOM-COOKIE-GET-RETURN      : -> MsgType [ctor] .

  op MSG-WRITE-FILE                 : -> MsgType [ctor] .
  op MSG-READ-FILE                  : -> MsgType [ctor] .
  op MSG-READ-FILE-RETURN           : -> MsgType [ctor] .
  op MSG-DOWNLOAD-INFO              : -> MsgType [ctor] .

**** see line 96ff in ibos_source/dOs/op.OBh --- These pieces of extra information
**** all go into the MsgVal field, they are in addition to the message
**** type being a webapp message.
sort MSGWEBAPPMSGVal .
subsort MSGWEBAPPMSGVal < MsgVal .
**** MsgType for all the values below:
  op MSG-WEBAPP-MSG                 : -> MsgType [ctor] .
  op MSG-WEBAPP-CLOSE               : -> MSGWEBAPPMSGVal [ctor] .
  op MSG-WEBAPP-SHOW                : -> MSGWEBAPPMSGVal [ctor] .
  op MSG-WEBAPP-HIDE                : -> MSGWEBAPPMSGVal [ctor] .
  op MSG-WEBAPP-LOAD-URL            : -> MSGWEBAPPMSGVal [ctor] .
  op MSG-WEBAPP-EVENT               : -> MSGWEBAPPMSGVal [ctor] .
**** above: MSG-WEBAPP-MSG type

sort MSGUIMSGVal .
subsort MSGUIMSGVal < MsgVal .
**** MsgType for all the values below:
  op MSG-UI-MSG                     : -> MsgType [ctor] .
  op MSG-loadStarted                : -> MSGUIMSGVal [ctor] . 
  op MSG-loadProgress               : -> MSGUIMSGVal [ctor] .
  op MSG-loadFinished               : -> MSGUIMSGVal [ctor] .
  op MSG-linkHovered                : -> MSGUIMSGVal [ctor] .
  op MSG-statusBarMessage           : -> MSGUIMSGVal [ctor] .
  op MSG-geometryChangeRequested    : -> MSGUIMSGVal [ctor] .
  op MSG-windowCloseRequested       : -> MSGUIMSGVal [ctor] .
  op MSG-toolBarVisibilityChangeRequested : -> MSGUIMSGVal [ctor] .
  op MSG-statusBarVisibilityChangeRequested : -> MSGUIMSGVal [ctor] .
  op MSG-menuBarVisibilityChangeRequested : -> MSGUIMSGVal [ctor] .
  op MSG-titleChanged               : -> MSGUIMSGVal [ctor] .
  op MSG-iconChanged                : -> MSGUIMSGVal [ctor] .
  op MSG-urlChanged                 : -> MSGUIMSGVal [ctor] .
  op MSG-addHistoryItem             : -> MSGUIMSGVal [ctor] .
  op MSG-navBackOrForward           : -> MSGUIMSGVal [ctor] .
  op MSG-webAppExited               : -> MSGUIMSGVal [ctor] .
**** above: MSG-UI-MSG
endm

mod SYSCALL-TYPE is 
  sort SyscallType .
**** this is from ibos_source/dKernel/service.cc
  op OPOS-SYSCALL-FD-SEND-MESSAGE :              -> SyscallType [ctor] .
  op OPOS-SYSCALL-CREATE-PROCESS :               -> SyscallType [ctor] .
  op OPOS-SYSCALL-REGISTER-IRQ-THREAD :          -> SyscallType [ctor] .
  op OPOS-SYSCALL-GET-RESERVE-MEM :              -> SyscallType [ctor] .
  op OPOS-SYSCALL-GET-SERVICE-TID :              -> SyscallType [ctor] .
  op OPOS-SYSCALL-REGISTER-SERVICE :             -> SyscallType [ctor] .
  op OPOS-SYSCALL-ALLOCATE-DMA-MEMORY :          -> SyscallType [ctor] .
  op OPOS-SYSCALL-POLL :                         -> SyscallType [ctor] .
  op OPOS-SYSCALL-FD-RECEIVE-MSSAGE :            -> SyscallType [ctor] .
  op OPOS-SYSCALL-E1000-SEND-ETHERNET-PACKET :   -> SyscallType [ctor] .
  op OPOS-SYSCALL-E1000-PARSE-INTERRUPT-RESULT : -> SyscallType [ctor] .
  op OPOS-SYSCALL-E1000-IF-UP :                  -> SyscallType [ctor] .
  op OPOS-SYSCALL-REGISTER-SUBSYSTEM :           -> SyscallType [ctor] .
  op OPOS-SYSCALL-GET-FB-MEMORY :                -> SyscallType [ctor] .
  op OPOS-SYSCALL-IS-WINDOW-MGR :                -> SyscallType [ctor] .
  op OPOS-SYSCALL-NET-IS-PORT-AVAILABLE :        -> SyscallType [ctor] .
  op OPOS-SYSCALL-NET-ALLOCATE-PORT :            -> SyscallType [ctor] .
  op OPOS-SYSCALL-NET-FREE-PORT :                -> SyscallType [ctor] .
  op OPOS-SYSCALL-TOUCH :                        -> SyscallType [ctor] .
endm

mod LABEL is
  protecting INAT .

  sort Domain .
**** Domains are now represented by natural numbers instead of strings (by Camilo)
  op dom : iNat -> Domain [ctor] .

**** Equality enrichment (added by Camilo)
  op _~_ : Domain Domain -> Bool .
  eq D:Domain ~ D:Domain
   = true .
  eq dom(N:iNat) ~ dom(N':iNat)
   = N:iNat ~ N':iNat .

  sort Port .
  op port : iNat -> Port [ctor] .

**** Equality enrichment (added by Camilo)
  op _~_ : Port Port -> Bool .
  eq P:Port ~ P:Port
   = true .
  eq port(N:iNat) ~ port(N':iNat)
   = N:iNat ~ N':iNat .

  sort Protocol .
  op http : -> Protocol [ctor] .
  op https : -> Protocol [ctor] .

**** Equality enrichment (added by Camilo)
  op _~_ : Protocol Protocol -> Bool .
  eq P:Protocol ~ P:Protocol
   = true .
  eq http ~ http 
   = true .
  eq https ~ https
   = true .
  eq http ~ https
   = false .
  eq https ~ http
   = false .

  sort Label .
  op about-blank : -> Label [ctor] .
  op l : Protocol Domain Port -> Label [ctor] .
  op url : iNat -> Label [ctor] .

**** Equality enrichment (added by Camilo)
  op _~_ : Label Label -> Bool .
  eq L:Label ~ L:Label
   = true .
  eq about-blank ~ about-blank
   = true .
  eq l(P:Protocol,D:Domain,Pt:Port) ~ l(P':Protocol,D':Domain,Pt':Port)
   = P:Protocol ~ P':Protocol and D:Domain ~ D':Domain and Pt:Port ~ Pt':Port .
  eq url(N:iNat) ~ url(N':iNat)
   = N:iNat ~ N':iNat .

  eq about-blank ~ l(P':Protocol,D':Domain,Pt':Port)
   = false .
  eq l(P':Protocol,D':Domain,Pt':Port) ~ about-blank
   = false .
  eq about-blank ~ url(N:iNat)
   = false .
  eq url(N:iNat) ~ about-blank
   = false .
  eq l(P:Protocol,D:Domain,Pt:Port) ~ url(N:iNat)
   = false .
  eq url(N:iNat) ~ l(P:Protocol,D:Domain,Pt:Port)
   = false .


  **** This subsorting is for ease of using URLs in messages. We could
  **** also just use strings for URLs but this is more convenient.

**** This subsorting was removed becaus strings are not really
**** used in the specification (by Camilo)

  sort LabelList .
  op mtLL : -> LabelList [ctor] .
  op _,_ : Label LabelList -> LabelList [ctor] .
  op _;_ : LabelList LabelList -> LabelList .
  eq mtLL ; LL':LabelList = LL':LabelList .
  eq (L:Label, LL:LabelList) ; LL':LabelList
   = L:Label, (LL:LabelList ; LL':LabelList) .
endm

mod PAYLOAD is
  protecting MSG-TYPE .
  protecting PROC-ID .

**** Removed dependecy from strings (by Camilo)
  protecting LABEL .

  sort typed . **** not actually used 
  op mtTyped : -> typed [ctor] .
  sort untyped . **** not actually used
  op mtUntyped : -> untyped [ctor] .
  sort Payload . 
**** correct sender Oid enforced by kernel
**** Removed dependency from Strings (by Camilo)
  op payload : Oid Oid MsgType MsgVal Label typed untyped -> Payload [ctor] .

**** This is how the payload is used in practice:
**** Sender - Receiver - Msg - Auxiliary Msg Info - URL (as Label) - unused - unused
endm


mod MSG-PIPE-BASICS is
  protecting SYSCALL-TYPE .
  protecting PAYLOAD  .

**** pipes are objects themselves, their Oid shows which object
**** communicates to the kernel on that pipe
  op pipe : -> Cid [ctor] .

**** messages added to the pipes under these wrappers for outgoing/incoming
  op fromKernel : MessageList -> Attribute [ctor] .
  op toKernel : MessageList -> Attribute [ctor] .

**** messages
  sort Message .
  sort MessageList .
  op msg : SyscallType Payload -> Message [ctor] .
**** Old msg version---  op msg : Oid Oid MsgType MsgVal String -> Message [ctor] .
  op none : -> Message [ctor] .
  op mt : -> MessageList [ctor] .
  op _,_ : Message MessageList -> MessageList [ctor] .
  op _;_ : MessageList MessageList -> MessageList .
  eq mt ; ML':MessageList = ML':MessageList .
  eq (M:Message, ML:MessageList) ; ML':MessageList 
   = M:Message, (ML:MessageList ; ML':MessageList) .
endm

mod WEBAPPMGR is
  inc MSG-PIPE-BASICS .
  *** next unused process id number for a web app
  op nextWAN : iNat -> Attribute [ctor] .
**** This attribute is used in the kernel, only. See for details:
**** ibos_source/dKernel/webappmgr.h/cc and ibos_source/dKernel/netprocmgr.h/cc
endm

mod WEBAPP is
  inc WEBAPPMGR .
  inc SYS .

**** Webapps have data to be put on screen - we only refer to it by
**** the label of the page where it is from.
  op rendered : Label -> Attribute [ctor] .
**** This is where the webapp should load its data from!
  op URL : Label -> Attribute [ctor] .
**** This notes whether it has already loaded, or has not yet started to do so.
  op loading : iNat -> Attribute [ctor] .

**** need the capability to check whether a process id is for a webapp
**** Changed to a more general definition that does not include Oid 
**** and that gets rid of the owise attribute (by Camilo)
  op isWebapp : ProcId -> Bool .
  eq isWebapp(Num:iNat) 
   = (1024 <= Num:iNat) and (Num:iNat < 1056) .
  eq isWebapp(id(Num:iNat)) 
   = Num:iNat ~ s(s(s(0))) .
endm

mod NETWORK is 
  inc MSG-PIPE-BASICS .
  inc SYS .
**** NETWORK is just receiving requests for data and answering them
**** right away once it is sent out by the NIC

****  need to be able to check if it is a network process

**** Changed to a more general definition that does not include Oid 
**** and that gets rid of the owise attribute (by Camilo)
  op isNetProc : ProcId -> Bool .
  eq isNetProc(Num:iNat) 
   = (256 <= Num:iNat) and (Num:iNat < 1023) .
  eq isNetProc(id(Num:iNat)) 
   = Num:iNat ~ s(s(s(s(0)))) .

  op returnTo : ProcId -> Attribute [ctor] .
  op in : LabelList -> Attribute [ctor] .
  op out : LabelList -> Attribute [ctor] .
endm

mod KERNEL-POLICIES is
  inc WEBAPP .
  inc NETWORK .

**** Policies are mostly browser-related, but can be on a lower level
**** [i.e., syscall level], e.g., for networkProc -> hardware
**** communication
  sort Policy .
  sort PolicySet .
  subsort Policy < PolicySet .
  op mtPS : -> PolicySet [ctor] .
  op _,_ : PolicySet PolicySet -> PolicySet [ctor assoc comm id: mtPS] .

**** make the policylist an attribute with this wrapper
  op msgPolicy : PolicySet -> Attribute [ctor] .
**** a policy is a sender Oid, receiver Oid and MsgType
  op policy : Oid Oid MsgType -> Policy [ctor] .

**** the next available proc id for a network proc
  op nextNetworkProc : iNat -> Attribute [ctor] .

**** the message currently handled by the kernel
  op handledCurrently : Message -> Attribute [ctor] .

****webapp info stored by kernel
  sort WebappProcInfo .
**** label identifies the website this webapp is showing - this needs to match the 
**** first label of a network proc to allow communication
  op pi : ProcId Label -> WebappProcInfo [ctor] . 

****network proc info stored by kernel
  sort NetworkProcInfo .
**** first label to identify related webapps, second label for whom
**** this network proc can communicate with (via actual ethernet; to outside world)
  op pi : ProcId Label Label -> NetworkProcInfo [ctor] . 

  sort WebappProcInfoSet .
  subsort WebappProcInfo < WebappProcInfoSet .
  op mtWPIS : -> WebappProcInfoSet [ctor] .
  op _,_ : WebappProcInfoSet WebappProcInfoSet -> WebappProcInfoSet [ctor assoc comm id: mtWPIS] .
  op weblabels : WebappProcInfoSet -> Attribute [ctor] .

  sort NetworkProcInfoSet .
  subsort NetworkProcInfo < NetworkProcInfoSet .
  op mtNPIS : -> NetworkProcInfoSet [ctor] .
  op _,_ : NetworkProcInfoSet NetworkProcInfoSet -> NetworkProcInfoSet [ctor assoc comm id: mtNPIS] .
  op networklabels : NetworkProcInfoSet -> Attribute [ctor] .

**** kernel-owned address bar - part of the 'secure' UI
  op displayedTopBar : Label -> Attribute [ctor] .

**** display memory modeled as an object.
***** See module PROC-ID
  op activeWebapp : ProcId -> Attribute [ctor] .

**** we only note the label of the things being displayed as an attribute of that object
  op displayedContent : Label -> Attribute [ctor] .

**** Kernel needs to do something
  op kernelDo : Message -> Message [ctor] .
endm

mod KERNEL is
**** A lot of the 'kernel' things are found above in 'KERNEL-POLICIES' instead
  inc KERNEL-POLICIES .

  vars Att Att2   : AttributeSet .
  var  Att3       : AttributeSet .
  var  Cnf        : Configuration .
  vars L L'       : Label .
  vars ML ML'     : MessageList .
  var  NPIS       : NetworkProcInfoSet .
  var  MP         : PolicySet .
  vars N N' ID    : ProcId .
  var  WPIS       : WebappProcInfoSet .

**** Page Fault and other invalid messages need not be modeled, as
**** they are simply dropped in the actual source code, and in the
**** model they will never be generated.

**** Made into a topmost labeled conditional rule from module WEBAPP (by Camilo)
 crl [fetch] :
     { < N : proc | rendered(L) , URL(L') , loading(0) , Att >
       < N : pipe | toKernel(ML) , Att2 > Cnf }
  => { < N : proc | rendered(L) , URL(L') , loading(s(0)) , Att >
       < N : pipe | toKernel(ML ; 
              (msg(OPOS-SYSCALL-FD-SEND-MESSAGE,
                  payload(N, id(s(s(s(s(0))))), MSG-FETCH-URL, 0, L', mtTyped, mtUntyped)),mt)) , 
              Att2 > Cnf }
  if isWebapp(N) .

**** Made into a labeled topmost conditional rule from module WEBAPP (by Camilo)
 crl [render] :
     { < N : proc | rendered(L) , URL(L') ,loading(s(0)) , Att >
       < N : pipe | fromKernel(
                     msg(OPOS-SYSCALL-FD-SEND-MESSAGE,
                         payload(N', N, MSG-RETURN-URL, V:MsgVal, LL:Label, T:typed, U:untyped)),
                     ML) , Att2 > Cnf }
  => { < N : proc | rendered(LL:Label) , URL(L') , loading(s(0)) , Att >
       < N : pipe | fromKernel(ML) , Att2 > Cnf }
  if isWebapp(N) .

**** Made into a topmost rule from module NETWORK (by Camilo)
 crl [request-from-webapp] : 
     { < N : proc | returnTo(SomeProcNum:iNat), out(Ll:LabelList) , Att > 
       < N : pipe | toKernel(ML), 
            fromKernel( 
              msg(OPOS-SYSCALL-FD-SEND-MESSAGE, 
                  payload(Num:iNat, N, MSG-FETCH-URL, V:MsgVal, L:Label, T:typed, U:untyped)), ML'), 
            Att2 > 
       Cnf } 
  => { < N : proc | returnTo(Num:iNat), out(Ll:LabelList ; (L:Label, mtLL)) , Att > 
       < N : pipe | toKernel(ML) , fromKernel(ML') , Att2 > 
       Cnf } 
  if isNetProc(N) .

**** Made into a labeled topmost conditional rule from module NETWORK (by Camilo)
 crl [proc-out] :
     { < N : proc | out(L:Label, Ll:LabelList) , Att >
       < N : mem | out(mtLL) , Att2 > Cnf }
  => { < N : proc | out(Ll:LabelList) , Att >
       < N : mem | out(L:Label,mtLL) , Att2 > Cnf }
  if isNetProc(N) .

**** Made into topmost labeled rules from module NETWORK (by Camilo)
  rl [nic0] :
     { < 0 : nic | out(L:Label, Ll:LabelList) , Att > Cnf }
  => { < 0 : nic | out(Ll:LabelList ; (L:Label, mtLL)) , Att > Cnf } .

  rl [nic1] :
     { < 0 : nic | out(L:Label, Ll:LabelList) , 
                   in(Ll'':LabelList) , Att > Cnf }
  => { < 0 : nic | out(Ll:LabelList) , 
                 in(Ll'':LabelList ; (L:Label, mtLL)) , Att > Cnf } .

**** Made into a labeled topmost rule from module NETWORK (by Camilo)
 crl [proc-in] :
     { < N : proc | in(Ll:LabelList) , Att >
       < N : mem | in(L:Label, mtLL) , Att2 > Cnf }
  => { < N : proc | in(Ll:LabelList ; (L:Label, mtLL)) , Att >
       < N : mem | in(mtLL) , Att2 > Cnf }
  if isNetProc(N) .

**** Made into a topmost conditional rule from module NETWORK (by Camilo)
 crl [msg-to-kernel] :
     { < N : proc | returnTo(Num:iNat) , in(L:Label, Ll:LabelList) , Att >
       < N : pipe | toKernel(ML) , fromKernel(ML') , Att2 > Cnf }
  => { < N : proc | returnTo(Num:iNat) , in(Ll:LabelList) , Att >
       < N : pipe | toKernel(ML ;
               (msg(OPOS-SYSCALL-FD-SEND-MESSAGE,
                   payload(N, Num:iNat, MSG-RETURN-URL, 0, L:Label, mtTyped, mtUntyped)),mt)) , 
                   fromKernel(ML') , Att2 > Cnf }
  if isNetProc(N) .

**** Made into a labeled topmost conditional rule from module KERNEL-POLICIES (by Camilo)
 crl [mem-out] :
     { < N : mem | out(L':Label, mtLL) , Att > 
       < id(s(0)) : kernel | 
           networklabels(pi(N, L:Label, L':Label), 
	   NPIS:NetworkProcInfoSet) ,
           Att2 >
       < 0 : nic | out(Ll:LabelList) , Att3 > Cnf }
  => { < N : mem | out(mtLL) , Att > 
       < id(s(0)) : kernel | 
           networklabels(pi(N, L:Label, L':Label), 
	   NPIS:NetworkProcInfoSet) ,
           Att2 >
       < 0 : nic | out(Ll:LabelList ; (L':Label, mtLL)) , Att3 > Cnf }
  if isNetProc(N) .

**** Made into a labeled topmost conditional rule from module KERNEL-POLICIES (by Camilo)
 crl [mem-in] :
     { < N : mem | in(mtLL) , Att > 
       < id(s(0)) : kernel | 
           networklabels(pi(N, L:Label, L':Label), NPIS:NetworkProcInfoSet) ,
           Att2 >
       < 0 : nic | in(L':Label, Ll:LabelList) , Att3 > Cnf }
  => { < N : mem | in(L':Label, mtLL) , Att > 
       < id(s(0)) : kernel | 
           networklabels(pi(N, L:Label, L':Label), NPIS:NetworkProcInfoSet) ,
           Att2 >
       < 0 : nic | in(Ll:LabelList) , Att3 > Cnf }
  if isNetProc(N) .

**** policy allows message from N to N' with M:MsgType
**** Made into a topmost rule from module KERNEL-POLICIES (by Camilo)
  rl [kernelReceivesOPMessage-pa1] :
     { < id(s(0)) : kernel | 
           handledCurrently(none), 
           msgPolicy(policy(N,N',M:MsgType),MP), 
           Att >
       < ID : pipe | 
           toKernel(msg(ST:SyscallType, payload(N, N', M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped)), ML), 
	   Att2 > 
       Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(
              msg(ST:SyscallType, payload(ID, N', M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped))), 
           msgPolicy(policy(N,N',M:MsgType),MP), Att >
       < ID : pipe | 
           toKernel(ML) , 
           Att2 > 
       Cnf } .

**** policy allows message from webapp Num:iNat to N' (not network proc) with M:MsgType
 crl [kernelReceivesOPMessage-pa2] :
     { < id(s(0)) : kernel | 
           handledCurrently(none), 
           msgPolicy(policy(id(s(s(s(0)))),N',M:MsgType),MP), 
           Att >
       < Num:iNat : pipe | 
           toKernel(msg(ST:SyscallType, payload(N, N', M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped)), ML), 
	   Att2 > 
       Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(
             msg(ST:SyscallType, payload(Num:iNat, N', M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped))),
           msgPolicy(policy(id(s(s(s(0)))),N',M:MsgType),MP), 
           Att >
       < Num:iNat : pipe | 
           toKernel(ML) , 
           Att2 > 
       Cnf }
  if isWebapp(Num:iNat) /\ not isNetProc(N') .

**** policy allows message from N (not network proc) to webapp Num':iNat with M:MsgType
 crl [kernelReceivesOPMessage-pa3] :
     { < id(s(0)) : kernel | 
           handledCurrently(none), 
           msgPolicy(policy(ID,id(s(s(s(0)))),M:MsgType),MP), 
           Att >
       < ID : pipe | 
           toKernel(msg(ST:SyscallType, payload(N, Num':iNat, M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped)), ML), 
	   Att2 > 
       Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(msg(ST:SyscallType, payload(ID, Num':iNat, M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped))),
           msgPolicy(policy(ID,id(s(s(s(0)))),M:MsgType),MP), 
           Att >
       < ID : pipe | 
           toKernel(ML) , 
           Att2 > 
       Cnf }
  if isWebapp(Num':iNat) /\ not isNetProc(ID) .


**** duplicated for network processes:
**** policy allows message from network process Num:Nat to N' (not webapp) with M:MsgType
 crl [kernelReceivesOPMessage-pa4] :
     { < id(s(0)) : kernel | 
           handledCurrently(none), 
           msgPolicy(policy(id(s(s(s(s(0))))),N',M:MsgType),MP), 
           Att >
       < Num:iNat : pipe | 
           toKernel(msg(ST:SyscallType, payload(N, N', M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped)), ML), 
	   Att2 > 
       Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(msg(ST:SyscallType, payload(Num:iNat, N', M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped))),
           msgPolicy(policy(id(s(s(s(s(0))))),N',M:MsgType),MP), 
           Att >
       < Num:iNat : pipe | 
           toKernel(ML), 
           Att2 > 
       Cnf }
  if isNetProc(Num:iNat) /\ not isWebapp(N') .


**** policy allows message from N (not webapp) to network process Num':iNat with M:MsgType
 crl [kernelReceivesOPMessage-pa5] :
     { < id(s(0)) : kernel | 
           handledCurrently(none), 
           msgPolicy(policy(ID,id(s(s(s(s(0))))),M:MsgType),MP), 
           Att >
       < ID : pipe | 
           toKernel(msg(ST:SyscallType, payload(N, Num':iNat, M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped)), ML), 
	   Att2 > 
       Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(msg(ST:SyscallType,payload(ID, Num':iNat, M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped))),
           msgPolicy(policy(ID,id(s(s(s(s(0))))),M:MsgType),MP), 
           Att >
       < ID : pipe | 
           toKernel(ML) , 
           Att2 > 
       Cnf }
  if isNetProc(Num':iNat) /\ not isWebapp(ID) .

**** auxiliary function for checking that no network process 
**** links to a given label
  op no-networkproc-for-label : Label NetworkProcInfoSet -> Bool .
  eq no-networkproc-for-label(L,mtNPIS)
   = true .
  eq no-networkproc-for-label(L,(pi(Num:iNat,L1:Label,L2:Label),NPIS))
   = not (L ~ L2:Label) and no-networkproc-for-label(L,NPIS) .
  eq no-networkproc-for-label(L,(pi(id(Num:iNat),L1:Label,L2:Label),NPIS))
   = no-networkproc-for-label(L,NPIS) .

**** policy allows message from webapp to network proc, but requires
**** further checking of them being connected based on the label -
**** that further check will deduce the actual target process and may
**** start a new one if necessary

**** Note how the webapp Num is labeled with L, thus the network proc
**** needs to have the first label L also. Additionally the target URL
**** L' needs to be the network proc's second label. Note that the 'target' network proc id Num' is totally ignored.
 crl [kernelReceivesOPMessage-pa6-cc2a] :
     { < id(s(0)) : kernel | 
           handledCurrently(none), 
           msgPolicy(policy(id(s(s(s(0)))),id(s(s(s(s(0))))),M:MsgType),MP), 
           weblabels(pi(Num:iNat,L),WPIS),
           networklabels(pi(Num'':iNat,L,S:Label),NPIS),
           Att >
       < Num:iNat : pipe | 
           toKernel(msg(ST:SyscallType, payload(N, N', M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped)), ML), 
	   Att2 > 
       Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(msg(ST:SyscallType, payload(Num:iNat, Num'':iNat, M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped))),
           msgPolicy(policy(id(s(s(s(0)))),id(s(s(s(s(0))))),M:MsgType),MP), 
           weblabels(pi(Num:iNat,L),WPIS),
           networklabels(pi(Num'':iNat,L,S:Label),NPIS),
           Att >
       < Num:iNat : pipe | 
           toKernel(ML) , 
           Att2 > 
       Cnf }
  if isWebapp(Num:iNat) /\ isNetProc(N') .


**** If no appropriate network process can be found in the above
**** rule, start a new network proc - this assumes that there will
**** be no more than 772 network procs started, to prevent that, we
**** would need to check "Num'' < 1024" :
 crl [kernelReceivesOPMessage-pa6-cc2b] :
     { < id(s(0)) : kernel | 
           handledCurrently(none), 
           msgPolicy(policy(id(s(s(s(0)))),id(s(s(s(s(0))))),M:MsgType),MP), 
       	   weblabels(pi(Num:iNat, L:Label), WPIS), 
       	   networklabels(NPIS),
       	   nextNetworkProc(Num'':iNat),
           Att >
       < Num:iNat : pipe | 
           toKernel(msg(ST:SyscallType, payload(N, N', M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped)), ML), 
	   Att2 > 
       Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(msg(ST:SyscallType, payload(Num:iNat, Num'':iNat, M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped))),
           msgPolicy(policy(id(s(s(s(0)))),id(s(s(s(s(0))))),M:MsgType),MP), 
       	   weblabels(pi(Num:iNat, L:Label), WPIS), 
       	   networklabels(pi(Num'':iNat,L:Label,S:Label),NPIS),
       	   nextNetworkProc(s(Num'':iNat)),
           Att >
       < Num:iNat : pipe | 
           toKernel(ML) , 
           Att2 > 
       < Num'':iNat : proc | returnTo(Num:iNat) , in(mtLL) , out(mtLL) >
       < Num'':iNat : mem | in(mtLL) , out(mtLL) >
       < Num'':iNat : pipe | toKernel(mt), fromKernel(mt) >
       Cnf }
  if isWebapp(Num:iNat) /\ isNetProc(N') /\ Num'':iNat < 1024 /\ no-networkproc-for-label(S:Label,NPIS) .


**** Auxiliary functions for checking connections for network procs and
**** webapps in the information sets that are defined in the kernel
  *** checks that the information of a given procid of sort natural is not in a set of
  *** network information
  op no-networkproc : iNat NetworkProcInfoSet -> Bool .
  eq [nnp1] :
     no-networkproc(Num:iNat,mtNPIS)
   = true .
  eq [ncfl2] :
     no-networkproc(Num:iNat,(pi(Num':iNat,L1:Label,L2:Label),NPIS))
   = not(Num:iNat ~ Num':iNat) and no-networkproc(Num:iNat,NPIS) .
  eq [ncfl3] :
     no-networkproc(Num:iNat,(pi(id(Num':iNat),L1:Label,L2:Label),NPIS))
   = no-networkproc(Num:iNat,NPIS) .

  *** checks that the information of a given procid of sort natural is not in a set of
  *** webapp information
  op no-webapp : iNat WebappProcInfoSet -> Bool .
  eq [nwp1] :
     no-webapp(Num:iNat,mtWPIS)
   = true .
  eq [ncfl2] :
     no-webapp(Num:iNat,(pi(Num':iNat,L1:Label),WPIS))
   = not(Num:iNat ~ Num':iNat) and no-webapp(Num:iNat,WPIS) .
  eq [ncfl3] :
     no-webapp(Num:iNat,(pi(id(Num':iNat),L1:Label),WPIS))
   = no-webapp(Num:iNat,WPIS) .


**** mirrored, for the reverse direction from network process to webapp:

**** there is a connection, just forward the message
**** network proc answering to webapp, thus having the correct recipient:
**** Made into a topmost equation (by Camilo)
 crl [kernelReceivesOPMessage-pa7-cc1a] :
     { < id(s(0)) : kernel | 
           handledCurrently(none), 
           msgPolicy(policy(id(s(s(s(s(0))))),id(s(s(s(0)))),M:MsgType),MP),
           weblabels(pi(Num':iNat,L),WPIS),
           networklabels(pi(Num:iNat,L,L'),NPIS),
           Att >
       < Num:iNat : pipe | 
           toKernel(msg(ST:SyscallType, payload(N, Num':iNat, M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped)), ML), 
	   Att2 > Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(msg(ST:SyscallType, payload(Num:iNat, Num':iNat, M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped))),
           msgPolicy(policy(id(s(s(s(s(0))))),id(s(s(s(0)))),M:MsgType),MP), 
           weblabels(pi(Num':iNat,L),WPIS),
           networklabels(pi(Num:iNat,L,L'),NPIS),
           Att >
       < Num:iNat : pipe | 
           toKernel(ML) , 
           Att2 > 
       Cnf }
  if isNetProc(Num:iNat) /\ isWebapp(Num':iNat) .

**** there is no connection, then drop the message
 crl [kernelReceivesOPMessage-pa7-cc1b] :
     { < id(s(0)) : kernel | 
           handledCurrently(none), 
           msgPolicy(policy(id(s(s(s(s(0))))),id(s(s(s(0)))),M:MsgType),MP), 
           weblabels(WPIS),
           networklabels(NPIS),
           Att >
       < Num:iNat : pipe | 
           toKernel(msg(ST:SyscallType, payload(N, Num':iNat, M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped)), ML), 
	   Att2 > Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(msg(ST:SyscallType, payload(Num:iNat, Num':iNat, M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped))),
           msgPolicy(policy(id(s(s(s(s(0))))),id(s(s(s(0)))),M:MsgType),MP), 
           weblabels(WPIS),
           networklabels(NPIS),
           Att >
       < Num:iNat : pipe | 
           toKernel(ML) , 
           Att2 > 
       Cnf }
  if isNetProc(Num:iNat) /\ isWebapp(Num':iNat) /\ no-networkproc(Num:iNat,NPIS) /\ no-webapp(Num':iNat,WPIS) .

**** policy allows message from UI to change current webapp to the
**** webapp Num':iNat with MSG-SWITCH-TAB
 crl [kernelReceivesOPMessage-pa8] :
     { < id(s(0)) : kernel | 
           handledCurrently(none), 
           msgPolicy(policy(id(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))),id(s(s(s(0)))),MSG-SWITCH-TAB),MP), 
           Att >
       < id(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) : pipe | 
           toKernel(msg(ST:SyscallType, payload(N, Num':iNat,MSG-SWITCH-TAB, V:MsgVal, S:Label, T:typed, U:untyped)), ML), 
	   Att2 > 
       Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(kernelDo(msg(ST:SyscallType, payload(id(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))),Num':iNat,MSG-SWITCH-TAB, V:MsgVal, S:Label, T:typed, U:untyped)))),
           msgPolicy(policy(id(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))),id(s(s(s(0)))),MSG-SWITCH-TAB),MP), 
           Att >
       < id(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) : pipe | 
           toKernel(ML), 
           Att2 > 
       Cnf }
  if isWebapp(Num':iNat) .

**** policy allows message from UI to change current webapp to
**** a new webapp loading URL with MSG-NEW-URL
  rl [kernelReceivesOPMessage-pa9] :
     { < id(s(0)) : kernel | 
           handledCurrently(none), 
           msgPolicy(policy(id(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))),id(s(s(s(0)))),MSG-NEW-URL),MP), 
           Att >
       < id(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) : pipe | 
           toKernel(msg(ST:SyscallType, payload(N,id(s(s(s(0)))), MSG-NEW-URL, V:MsgVal, S:Label, T:typed, U:untyped)), ML), 
	   Att2 > 
       Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(kernelDo(msg(ST:SyscallType, payload(id(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))), id(s(s(s(0)))), MSG-NEW-URL, V:MsgVal, S:Label, T:typed, U:untyped)))),
           msgPolicy(policy(id(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))),id(s(s(s(0)))),MSG-NEW-URL),MP), 
           Att >
       < id(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) : pipe | 
           toKernel(ML) , 
           Att2 > 
       Cnf } .

**** no policy allowed this, therefore implicitly disallowed and dropped
  rl [kernelReceivesOPMessage-pa10] :
     { < id(s(0)) : kernel | 
           handledCurrently(none), 
           msgPolicy(MP), 
           Att >
       < ID : pipe | 
           toKernel(msg(ST:SyscallType, payload(N, N', M:MsgType, V:MsgVal, S:Label, T:typed, U:untyped)), ML), 
	   Att2 > 
       Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(none),
           msgPolicy(MP), 
           Att >
       < ID : pipe | 
           toKernel(ML), 
           Att2 > 
       Cnf } .

**** Made into a topmost rule from module KERNEL-POLICIES (by Camilo)
 rl [kernelForwardsOPMessage] :
     { < id(s(0)) : kernel | 
         handledCurrently(
                msg(ST:SyscallType, 
                    payload(ID, N', M:MsgType, V:MsgVal, S:Label, 
                            T:typed, U:untyped))) , 
         Att >
       < N' : pipe | fromKernel(ML) , Att2 > Cnf }
  =>
     { < id(s(0)) : kernel | handledCurrently(none), Att >
       < N' : pipe | fromKernel(ML ;
                    (msg(ST:SyscallType, 
                        payload(ID, N', M:MsgType, V:MsgVal, S:Label, 
                                T:typed, U:untyped)),mt)) , 
                   Att2 > Cnf } .

**** Made into a topmost rule from module KERNEL-POLICIES (by Camilo)
  rl [tab-change] :
     { < id(s(0)) : kernel | 
           handledCurrently(kernelDo(
             msg(ST:SyscallType, 
                 payload(id(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))), N', MSG-SWITCH-TAB, V:MsgVal, S:Label, 
                         T:typed, U:untyped)))) , 
           displayedTopBar(L:Label),
           weblabels(pi(N', L':Label), WPIS:WebappProcInfoSet) , 
           Att > 
       < id(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))) : proc | 
           activeWebapp(P:ProcId),
           displayedContent(L'':Label),
           Att2 > Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(none) , 
      	   displayedTopBar(L':Label),
      	   weblabels(pi(N', L':Label), WPIS:WebappProcInfoSet) , 
      	   Att >
       < id(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))) : proc | 
           activeWebapp(N'),
           displayedContent(about-blank),
           Att2 > Cnf } .

**** Made into a tomost rule that uses equality enrichment in the condition
**** from module KERNEL-POLICIES (by Camilo)
**** Q. what could be wrong with this since the number of solutions
**** in one of the experiments change (Camilo) See equational enrichment
**** for labels.
**** A. there was another constructor for label in the specification;
**** such a definition was moved to module LABEL and the equality
**** enrichment defined accordingly
 crl [change-display] :
     { < id(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))) : proc | activeWebapp(N), displayedContent(LOld:Label), Att2 >
       < N : proc | rendered(L:Label), Att3 > Cnf }
  => { < id(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))) : proc | activeWebapp(N), displayedContent(L:Label), Att2 >
       < N : proc | rendered(L:Label), Att3 > Cnf }
  if LOld:Label ~ L:Label = false
  /\ isWebapp(N) .

**** Made into a topmost rule from module KERNEL-POLICIES (by Camilo)
 crl [new-url] :
     { < id(s(0)) : kernel | 
           handledCurrently(kernelDo(
             msg(ST:SyscallType, 
                 payload(id(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))), id(s(s(s(0)))), MSG-NEW-URL, V:MsgVal, URL:Label, 
                         T:typed, U:untyped)))) , 
           displayedTopBar(L:Label),
      	   weblabels(WPIS:WebappProcInfoSet) , 
      	   Att >
       < id(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))) : proc | 
           activeWebapp(P:ProcId),
    	   displayedContent(L'':Label),
    	   Att2 >
       < id(s(s(0))) : proc | nextWAN(NewWA:iNat) , Att3 > Cnf }
  =>
     { < id(s(0)) : kernel | 
           handledCurrently(none) , 
      	   displayedTopBar(URL:Label),
      	   weblabels(pi(NewWA:iNat, URL:Label), WPIS:WebappProcInfoSet) , 
      	   Att >
       < id(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))) : proc | 
           activeWebapp(NewWA:iNat),
           displayedContent(about-blank),
           Att2 >
       < id(s(s(0))) : proc | nextWAN(s(NewWA:iNat)) , Att3 >
       < NewWA:iNat : proc | 
           rendered(about-blank) ,
           URL(URL:Label) ,
           loading(0) > 
       < NewWA:iNat : pipe |
           fromKernel(mt),
           toKernel(mt) > Cnf }
  if NewWA:iNat < 1056 .
endm
